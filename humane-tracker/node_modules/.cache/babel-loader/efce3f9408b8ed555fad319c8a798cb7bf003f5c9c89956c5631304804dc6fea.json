{"ast":null,"code":"import { collection, doc, setDoc, getDocs, query, where, orderBy, Timestamp, deleteDoc, onSnapshot, addDoc } from 'firebase/firestore';\nimport { db } from '../config/firebase';\nimport { startOfWeek, endOfWeek, isToday, differenceInDays } from 'date-fns';\nexport class HabitService {\n  constructor() {\n    this.habitsCollection = collection(db, 'habits');\n    this.entriesCollection = collection(db, 'entries');\n  }\n  // Create a new habit\n  async createHabit(habit) {\n    const newHabit = {\n      ...habit,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    };\n    const docRef = await addDoc(this.habitsCollection, newHabit);\n    return docRef.id;\n  }\n\n  // Get all habits for a user\n  async getUserHabits(userId) {\n    const q = query(this.habitsCollection, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  }\n\n  // Subscribe to habits changes\n  subscribeToHabits(userId, callback) {\n    const q = query(this.habitsCollection, where('userId', '==', userId));\n    return onSnapshot(q, snapshot => {\n      const habits = snapshot.docs.map(doc => {\n        var _data$createdAt, _data$updatedAt;\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          createdAt: (_data$createdAt = data.createdAt) !== null && _data$createdAt !== void 0 && _data$createdAt.toDate ? data.createdAt.toDate() : new Date(),\n          updatedAt: (_data$updatedAt = data.updatedAt) !== null && _data$updatedAt !== void 0 && _data$updatedAt.toDate ? data.updatedAt.toDate() : new Date()\n        };\n      });\n      callback(habits);\n    });\n  }\n\n  // Add a habit entry\n  async addEntry(entry) {\n    const newEntry = {\n      ...entry,\n      date: Timestamp.fromDate(entry.date),\n      createdAt: Timestamp.now()\n    };\n    const docRef = await addDoc(this.entriesCollection, newEntry);\n    return docRef.id;\n  }\n\n  // Get entries for a habit within a date range\n  async getHabitEntries(habitId, startDate, endDate) {\n    const q = query(this.entriesCollection, where('habitId', '==', habitId), where('date', '>=', Timestamp.fromDate(startDate)), where('date', '<=', Timestamp.fromDate(endDate)), orderBy('date', 'desc'));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => {\n      var _data$date, _data$createdAt2;\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        date: (_data$date = data.date) !== null && _data$date !== void 0 && _data$date.toDate ? data.date.toDate() : new Date(),\n        createdAt: (_data$createdAt2 = data.createdAt) !== null && _data$createdAt2 !== void 0 && _data$createdAt2.toDate ? data.createdAt.toDate() : new Date()\n      };\n    });\n  }\n\n  // Subscribe to entries changes for a week\n  subscribeToWeekEntries(userId, weekStart, weekEnd, callback) {\n    const q = query(this.entriesCollection, where('userId', '==', userId), where('date', '>=', Timestamp.fromDate(weekStart)), where('date', '<=', Timestamp.fromDate(weekEnd)));\n    return onSnapshot(q, snapshot => {\n      const entries = snapshot.docs.map(doc => {\n        var _data$date2, _data$createdAt3;\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          date: (_data$date2 = data.date) !== null && _data$date2 !== void 0 && _data$date2.toDate ? data.date.toDate() : new Date(),\n          createdAt: (_data$createdAt3 = data.createdAt) !== null && _data$createdAt3 !== void 0 && _data$createdAt3.toDate ? data.createdAt.toDate() : new Date()\n        };\n      });\n      callback(entries);\n    });\n  }\n\n  // Calculate habit status\n  calculateHabitStatus(habit, entries, currentDate = new Date()) {\n    const weekStart = startOfWeek(currentDate, {\n      weekStartsOn: 1\n    }); // Week starts on Monday\n    const weekEnd = endOfWeek(currentDate, {\n      weekStartsOn: 1\n    });\n    const weekEntries = entries.filter(e => e.date >= weekStart && e.date <= weekEnd);\n    const totalValue = weekEntries.reduce((sum, e) => sum + e.value, 0);\n    const todayEntry = weekEntries.find(e => isToday(e.date));\n\n    // Check if done today\n    if (todayEntry && todayEntry.value >= 1) {\n      return 'done';\n    }\n\n    // Check if weekly target is met\n    if (totalValue >= habit.targetPerWeek) {\n      return 'met';\n    }\n\n    // Calculate days left and entries needed\n    const daysLeft = differenceInDays(weekEnd, currentDate) + 1;\n    const entriesNeeded = habit.targetPerWeek - totalValue;\n\n    // Check if due today\n    if (daysLeft <= entriesNeeded && !todayEntry) {\n      if (daysLeft === 0) return 'overdue';\n      if (daysLeft === 1) return 'today';\n      if (daysLeft === 2) return 'tomorrow';\n      return 'soon';\n    }\n    return 'pending';\n  }\n\n  // Get habits with status for current week\n  async getHabitsWithStatus(userId) {\n    const habits = await this.getUserHabits(userId);\n    const currentDate = new Date();\n    const weekStart = startOfWeek(currentDate, {\n      weekStartsOn: 1\n    });\n    const weekEnd = endOfWeek(currentDate, {\n      weekStartsOn: 1\n    });\n    const habitsWithStatus = [];\n    for (const habit of habits) {\n      const entries = await this.getHabitEntries(habit.id, weekStart, weekEnd);\n      const status = this.calculateHabitStatus(habit, entries, currentDate);\n      const currentWeekCount = entries.reduce((sum, e) => sum + e.value, 0);\n      habitsWithStatus.push({\n        ...habit,\n        status,\n        currentWeekCount,\n        entries\n      });\n    }\n    return habitsWithStatus;\n  }\n\n  // Update entry value\n  async updateEntry(entryId, value) {\n    const entryRef = doc(this.entriesCollection, entryId);\n    await setDoc(entryRef, {\n      value\n    }, {\n      merge: true\n    });\n  }\n\n  // Delete entry\n  async deleteEntry(entryId) {\n    await deleteDoc(doc(this.entriesCollection, entryId));\n  }\n}","map":{"version":3,"names":["collection","doc","setDoc","getDocs","query","where","orderBy","Timestamp","deleteDoc","onSnapshot","addDoc","db","startOfWeek","endOfWeek","isToday","differenceInDays","HabitService","constructor","habitsCollection","entriesCollection","createHabit","habit","newHabit","createdAt","now","updatedAt","docRef","id","getUserHabits","userId","q","snapshot","docs","map","data","subscribeToHabits","callback","habits","_data$createdAt","_data$updatedAt","toDate","Date","addEntry","entry","newEntry","date","fromDate","getHabitEntries","habitId","startDate","endDate","_data$date","_data$createdAt2","subscribeToWeekEntries","weekStart","weekEnd","entries","_data$date2","_data$createdAt3","calculateHabitStatus","currentDate","weekStartsOn","weekEntries","filter","e","totalValue","reduce","sum","value","todayEntry","find","targetPerWeek","daysLeft","entriesNeeded","getHabitsWithStatus","habitsWithStatus","status","currentWeekCount","push","updateEntry","entryId","entryRef","merge","deleteEntry"],"sources":["/Users/idvorkin/gits/humane-tracker-1/humane-tracker/src/services/habitService.ts"],"sourcesContent":["import { \n  collection, \n  doc, \n  setDoc, \n  getDocs, \n  query, \n  where, \n  orderBy, \n  Timestamp,\n  deleteDoc,\n  onSnapshot,\n  addDoc\n} from 'firebase/firestore';\nimport { db } from '../config/firebase';\nimport { Habit, HabitEntry, HabitWithStatus, HabitStatus } from '../types/habit';\nimport { startOfWeek, endOfWeek, isToday, differenceInDays } from 'date-fns';\n\nexport class HabitService {\n  private habitsCollection = collection(db, 'habits');\n  private entriesCollection = collection(db, 'entries');\n\n  // Create a new habit\n  async createHabit(habit: Omit<Habit, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const newHabit = {\n      ...habit,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    };\n    const docRef = await addDoc(this.habitsCollection, newHabit);\n    return docRef.id;\n  }\n\n  // Get all habits for a user\n  async getUserHabits(userId: string): Promise<Habit[]> {\n    const q = query(this.habitsCollection, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    } as Habit));\n  }\n\n  // Subscribe to habits changes\n  subscribeToHabits(userId: string, callback: (habits: Habit[]) => void) {\n    const q = query(this.habitsCollection, where('userId', '==', userId));\n    return onSnapshot(q, (snapshot) => {\n      const habits = snapshot.docs.map(doc => {\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(),\n          updatedAt: data.updatedAt?.toDate ? data.updatedAt.toDate() : new Date()\n        } as Habit;\n      });\n      callback(habits);\n    });\n  }\n\n  // Add a habit entry\n  async addEntry(entry: Omit<HabitEntry, 'id' | 'createdAt'>): Promise<string> {\n    const newEntry = {\n      ...entry,\n      date: Timestamp.fromDate(entry.date),\n      createdAt: Timestamp.now()\n    };\n    const docRef = await addDoc(this.entriesCollection, newEntry);\n    return docRef.id;\n  }\n\n  // Get entries for a habit within a date range\n  async getHabitEntries(habitId: string, startDate: Date, endDate: Date): Promise<HabitEntry[]> {\n    const q = query(\n      this.entriesCollection,\n      where('habitId', '==', habitId),\n      where('date', '>=', Timestamp.fromDate(startDate)),\n      where('date', '<=', Timestamp.fromDate(endDate)),\n      orderBy('date', 'desc')\n    );\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        date: data.date?.toDate ? data.date.toDate() : new Date(),\n        createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date()\n      } as HabitEntry;\n    });\n  }\n\n  // Subscribe to entries changes for a week\n  subscribeToWeekEntries(userId: string, weekStart: Date, weekEnd: Date, callback: (entries: HabitEntry[]) => void) {\n    const q = query(\n      this.entriesCollection,\n      where('userId', '==', userId),\n      where('date', '>=', Timestamp.fromDate(weekStart)),\n      where('date', '<=', Timestamp.fromDate(weekEnd))\n    );\n    return onSnapshot(q, (snapshot) => {\n      const entries = snapshot.docs.map(doc => {\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          date: data.date?.toDate ? data.date.toDate() : new Date(),\n          createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date()\n        } as HabitEntry;\n      });\n      callback(entries);\n    });\n  }\n\n  // Calculate habit status\n  calculateHabitStatus(habit: Habit, entries: HabitEntry[], currentDate: Date = new Date()): HabitStatus {\n    const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 }); // Week starts on Monday\n    const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });\n    \n    const weekEntries = entries.filter(e => \n      e.date >= weekStart && e.date <= weekEnd\n    );\n    \n    const totalValue = weekEntries.reduce((sum, e) => sum + e.value, 0);\n    const todayEntry = weekEntries.find(e => isToday(e.date));\n    \n    // Check if done today\n    if (todayEntry && todayEntry.value >= 1) {\n      return 'done';\n    }\n    \n    // Check if weekly target is met\n    if (totalValue >= habit.targetPerWeek) {\n      return 'met';\n    }\n    \n    // Calculate days left and entries needed\n    const daysLeft = differenceInDays(weekEnd, currentDate) + 1;\n    const entriesNeeded = habit.targetPerWeek - totalValue;\n    \n    // Check if due today\n    if (daysLeft <= entriesNeeded && !todayEntry) {\n      if (daysLeft === 0) return 'overdue';\n      if (daysLeft === 1) return 'today';\n      if (daysLeft === 2) return 'tomorrow';\n      return 'soon';\n    }\n    \n    return 'pending';\n  }\n\n  // Get habits with status for current week\n  async getHabitsWithStatus(userId: string): Promise<HabitWithStatus[]> {\n    const habits = await this.getUserHabits(userId);\n    const currentDate = new Date();\n    const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 });\n    const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });\n    \n    const habitsWithStatus: HabitWithStatus[] = [];\n    \n    for (const habit of habits) {\n      const entries = await this.getHabitEntries(habit.id, weekStart, weekEnd);\n      const status = this.calculateHabitStatus(habit, entries, currentDate);\n      const currentWeekCount = entries.reduce((sum, e) => sum + e.value, 0);\n      \n      habitsWithStatus.push({\n        ...habit,\n        status,\n        currentWeekCount,\n        entries\n      });\n    }\n    \n    return habitsWithStatus;\n  }\n\n  // Update entry value\n  async updateEntry(entryId: string, value: number): Promise<void> {\n    const entryRef = doc(this.entriesCollection, entryId);\n    await setDoc(entryRef, { value }, { merge: true });\n  }\n\n  // Delete entry\n  async deleteEntry(entryId: string): Promise<void> {\n    await deleteDoc(doc(this.entriesCollection, entryId));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}